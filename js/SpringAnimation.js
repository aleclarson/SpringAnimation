// Generated by CoffeeScript 1.12.4
var Animation, SpringAnimation, SpringConfig, Type, isDev, type;

Animation = require("Animated").Animation;

isDev = require("isDev");

Type = require("Type");

SpringConfig = require("./SpringConfig");

type = Type("SpringAnimation");

type.inherits(Animation);

type.defineArgs(function() {
  return {
    required: {
      toValue: true
    },
    types: {
      toValue: Number,
      velocity: Number,
      bounciness: Number,
      speed: Number,
      tension: Number,
      friction: Number,
      clamp: Boolean,
      restDistance: Number,
      restVelocity: Number
    },
    defaults: {
      velocity: 0,
      clamp: false,
      restDistance: 0.01,
      restVelocity: 0.001
    }
  };
});

type.defineFrozenValues(function(options) {
  return {
    toValue: options.toValue,
    clamp: options.clamp,
    restDistance: options.restDistance,
    restVelocity: options.restVelocity
  };
});

type.defineValues({
  time: null,
  value: null,
  velocity: null,
  startVelocity: null,
  tension: null,
  friction: null
});

type.initInstance(function(options) {
  var spring;
  this.value = this.fromValue;
  this.velocity = this.startVelocity = options.velocity;
  spring = this._getSpringConfig(options);
  this.tension = spring.tension;
  return this.friction = spring.friction;
});

type.defineMethods({
  _getSpringConfig: function(options) {
    if ((options.bounciness != null) || (options.speed != null)) {
      if (!((options.tension != null) || (options.friction != null))) {
        throw Error("Cannot define bounciness or speed with tension or friction!");
      }
      if (options.speed == null) {
        options.speed = 12;
      }
      if (options.bounciness == null) {
        options.bounciness = 8;
      }
      return SpringConfig.fromBouncinessAndSpeed(options);
    }
    if (options.tension == null) {
      options.tension = 40;
    }
    if (options.friction == null) {
      options.friction = 7;
    }
    return SpringConfig.fromOrigamiTensionAndFriction(options);
  },
  _shouldClamp: function() {
    if (this.fromValue < this.toValue) {
      return this.value > this.toValue;
    } else {
      return this.value < this.toValue;
    }
  },
  _shouldFinish: function() {
    if (this.isDone) {
      return false;
    }
    if (this.clamp && this.tension !== 0) {
      if (this._shouldClamp()) {
        return true;
      }
    }
    if (Math.abs(this.velocity) <= this.restVelocity) {
      return Math.abs(this.toValue - this.value) <= this.restDistance;
    }
    return false;
  }
});

type.overrideMethods({
  _startAnimation: function(animated) {
    var anim;
    anim = this._previousAnimation;
    if (anim instanceof SpringAnimation) {
      this.time = this.startTime = anim.time;
      this.value = this.fromValue = anim.value;
      this.velocity = this.startVelocity = anim.velocity;
    } else {
      if (this.fromValue != null) {
        animated._updateValue(this.fromValue);
      } else {
        this.fromValue = animated._value;
      }
      this.value = this.fromValue;
      this.time = this.startTime = Date.now();
    }
    this.__onAnimationStart(animated);
  },
  __onAnimationStart: function(animated) {
    if (this._useNativeDriver) {
      return this._startNativeAnimation(animated);
    } else {
      return this._recomputeValue();
    }
  },
  __computeValue: function() {
    var MAX_STEPS, TIMESTEP_MSEC, aAcceleration, aVelocity, bAcceleration, bVelocity, cAcceleration, cVelocity, dAcceleration, dVelocity, dvdt, dxdt, i, j, now, numSteps, ref, ref1, step, tempValue, tempVelocity, value, velocity;
    ref = this, value = ref.value, velocity = ref.velocity;
    tempValue = value;
    tempVelocity = velocity;
    MAX_STEPS = 64;
    now = Date.now();
    if (now > this.time + MAX_STEPS) {
      now = this.time + MAX_STEPS;
    }
    TIMESTEP_MSEC = 1;
    numSteps = Math.floor((now - this.time) / TIMESTEP_MSEC);
    for (i = j = 0, ref1 = numSteps; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
      step = TIMESTEP_MSEC / 1000;
      aVelocity = velocity;
      aAcceleration = this.tension * (this.toValue - tempValue) - this.friction * tempVelocity;
      tempValue = value + aVelocity * step / 2;
      tempVelocity = velocity + aAcceleration * step / 2;
      bVelocity = velocity;
      bAcceleration = this.tension * (this.toValue - tempValue) - this.friction * tempVelocity;
      tempValue = value + bVelocity * step / 2;
      tempVelocity = velocity + bAcceleration * step / 2;
      cVelocity = velocity;
      cAcceleration = this.tension * (this.toValue - tempValue) - this.friction * tempVelocity;
      tempValue = value + cVelocity * step / 2;
      tempVelocity = velocity + cAcceleration * step / 2;
      dVelocity = velocity;
      dAcceleration = this.tension * (this.toValue - tempValue) - this.friction * tempVelocity;
      tempValue = value + dVelocity * step / 2;
      tempVelocity = velocity + dAcceleration * step / 2;
      dxdt = (aVelocity + 2 * (bVelocity + cVelocity) + dVelocity) / 6;
      dvdt = (aAcceleration + 2 * (bAcceleration + cAcceleration) + dAcceleration) / 6;
      value += dxdt * step;
      velocity += dvdt * step;
    }
    if (isDev) {
      this._assertNumber(value);
      this._assertNumber(velocity);
    }
    this.time = now;
    this.velocity = velocity;
    return this.value = value;
  },
  __onAnimationUpdate: function(value) {
    if (this._shouldFinish()) {
      this.stop(true);
    }
  },
  __onAnimationEnd: function(finished) {
    if (!finished) {
      return;
    }
    if (this.tension === 0) {
      return;
    }
    return this._onUpdate(this.toValue);
  },
  __captureFrame: function() {
    return {
      time: this.time,
      value: this.value,
      velocity: this.velocity
    };
  },
  __getNativeConfig: function() {
    return {
      type: "spring",
      toValue: this.toValue,
      startVelocity: this.startVelocity,
      clamp: this.clamp,
      tension: this.tension,
      friction: this.friction,
      restDistance: this.restDistance,
      restVelocity: this.restVelocity
    };
  }
});

module.exports = SpringAnimation = type.build();
